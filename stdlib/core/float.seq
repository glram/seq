extend float:

# Magic methods

    def __new__(s: str) -> float:
        buf = __array__[byte](32)
        n = len(s)
        need_dyn_alloc = (n >= len(buf))

        p = _gc.alloc_atomic(n + 1) if need_dyn_alloc else buf.ptr
        str.memcpy(p, s.ptr, n)
        p[n] = byte(0)

        end = cobj()
        result = _C.strtod(p, __ptr__(end))

        if need_dyn_alloc:
            _gc.free(p)

        if end != p + n:
            raise ValueError(f"could not convert string to float: {s}")

        return result

    def __hash__(self: float):
        HASH_BITS = 61
        HASH_MODULUS = (1 << HASH_BITS) - 1
        HASH_INF = 314159
        HASH_NAN = 0
        INF = 1.0 / 0.0
        NAN = 0.0 / 0.0
        v = self

        if v == INF or v == -INF:
            return HASH_INF if v > 0 else -HASH_INF
        if v == NAN:
            return HASH_NAN

        _e = i32(0)
        m = _C.frexp(v, __ptr__(_e))
        e = int(_e)

        sign = 1
        if m < 0:
            sign = -1
            m = -m

        x = 0
        while m:
            x = ((x << 28) & HASH_MODULUS) | x >> (HASH_BITS - 28)
            m *= 268435456.0  # 2**28
            e -= 28
            y = int(m)
            m -= y
            x += y
            if x >= HASH_MODULUS:
                x -= HASH_MODULUS

        e = e % HASH_BITS if e >= 0 else HASH_BITS - 1 - ((-1-e) % HASH_BITS)
        x = ((x << e) & HASH_MODULUS) | x >> (HASH_BITS - e)

        x = x * sign
        if x == -1:
            x = -2
        return x
