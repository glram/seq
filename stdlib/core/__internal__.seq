# @trait
# @internal
# class Iterable[T]:
#     pass


extend str:
    @internal
    def __new__(p: Ptr[byte], l: int) -> str: pass

    def _tuple_str(strs: Ptr[str], n: int) -> str:
        total = 2  # one for each of '(' and ')'
        i = 0
        while i < n:
            total += strs[i].len
            if i < n - 1:
                total += 2  # ", "
            i += 1

        buf = Ptr[byte](total)
        where = 0
        buf[where] = byte(40)  # '('
        where += 1

        i = 0
        while i < n:
            s = strs[i]
            l = s.len
            str.memcpy(buf + where, s.ptr, l)
            where += l
            if i < n - 1:
                buf[where] = byte(44)  # ','
                where += 1
                buf[where] = byte(32)  # ' '
                where += 1
            i += 1
        buf[where] = byte(41)  # ')'

        return str(buf, total)

extend pyobj:
    @internal
    def __new__(p: Ptr[byte]) -> pyobj: pass

cimport seq_print(str)

extend Ptr[T]:
    @internal
    def __elemsize__() -> int: pass
    @internal
    def __atomic__() -> bool: pass
    @internal
    def as_byte(self) -> Ptr[byte]: pass
    @internal
    def __new__() -> Ptr[T]: pass
    @internal
    def __new__(other: Ptr[byte]) -> Ptr[T]: pass
    @internal
    def __new__(sz: int) -> Ptr[T]: pass
    @internal
    def __new__(other: Ptr[T]) -> Ptr[T]: pass
    @internal
    def __int__(self) -> int: pass
    @internal
    def __copy__(self) -> Ptr[T]: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __getitem__(self, index: int) -> T: pass
    @internal
    def __setitem__(self, index: int, what: T) -> void: pass
    @internal
    def __add__(self, other: int) -> Ptr[T]: pass
    @internal
    def __sub__(self, other: Ptr[T]) -> int: pass
    @internal
    def __eq__(self, other: Ptr[T]) -> bool: pass
    @internal
    def __ne__(self, other: Ptr[T]) -> bool: pass
    @internal
    def __lt__(self, other: Ptr[T]) -> bool: pass
    @internal
    def __gt__(self, other: Ptr[T]) -> bool: pass
    @internal
    def __le__(self, other: Ptr[T]) -> bool: pass
    @internal
    def __ge__(self, other: Ptr[T]) -> bool: pass
    @internal
    def __prefetch_r0__(self) -> void: pass
    @internal
    def __prefetch_r1__(self) -> void: pass
    @internal
    def __prefetch_r2__(self) -> void: pass
    @internal
    def __prefetch_r3__(self) -> void: pass
    @internal
    def __prefetch_w0__(self) -> void: pass
    @internal
    def __prefetch_w1__(self) -> void: pass
    @internal
    def __prefetch_w2__(self) -> void: pass
    @internal
    def __prefetch_w3__(self) -> void: pass
ptr = Ptr

extend int:
    @internal
    def __new__() -> int: pass
    def __new__[T](what: T) -> int: # lowest priority!
        return what.__int__()
    @internal
    def __new__(i: int) -> int: pass
    @internal
    def __new__(f: float) -> int: pass
    @internal
    def __new__(b: bool) -> int: pass
    @internal
    def __new__(b: bool) -> int: pass
    @internal
    def __new__(b: byte) -> int: pass
    @internal
    def __new__[N: int](b: Int[N]) -> int: pass
    @internal
    def __new__[N: int](b: UInt[N]) -> int: pass
    @internal
    def __int__(self) -> int: pass
    @internal
    def __str__(self) -> str: pass
    @internal
    def __copy__(self) -> int: pass
    @internal
    def __hash__(self) -> int: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __pos__(self) -> int: pass
    @internal
    def __neg__(self) -> int: pass
    @internal
    def __invert__(self) -> int: pass
    @internal
    def __abs__(self) -> int: pass
    @internal
    def __add__(self, other: int) -> int: pass
    @internal
    def __sub__(self, other: int) -> int: pass
    @internal
    def __mul__(self, other: int) -> int: pass
    @internal
    def __div__(self, other: int) -> int: pass
    @internal
    def __truediv__(self, other: int) -> float: pass
    @internal
    def __mod__(self, other: int) -> int: pass
    @internal
    def __lshift__(self, other: int) -> int: pass
    @internal
    def __rshift__(self, other: int) -> int: pass
    @internal
    def __eq__(self, other: int) -> bool: pass
    @internal
    def __ne__(self, other: int) -> bool: pass
    @internal
    def __lt__(self, other: int) -> bool: pass
    @internal
    def __gt__(self, other: int) -> bool: pass
    @internal
    def __le__(self, other: int) -> bool: pass
    @internal
    def __ge__(self, other: int) -> bool: pass
    @internal
    def __and__(self, other: int) -> int: pass
    @internal
    def __or__(self, other: int) -> int: pass
    @internal
    def __xor__(self, other: int) -> int: pass
    @internal
    def __add__(self, other: float) -> float: pass
    @internal
    def __sub__(self, other: float) -> float: pass
    @internal
    def __mul__(self, other: float) -> float: pass
    @internal
    def __div__(self, other: float) -> float: pass
    @internal
    def __truediv__(self, other: float) -> float: pass
    @internal
    def __mod__(self, other: float) -> float: pass
    @internal
    def __eq__(self, other: float) -> bool: pass
    @internal
    def __ne__(self, other: float) -> bool: pass
    @internal
    def __lt__(self, other: float) -> bool: pass
    @internal
    def __gt__(self, other: float) -> bool: pass
    @internal
    def __le__(self, other: float) -> bool: pass
    @internal
    def __ge__(self, other: float) -> bool: pass

extend str:
    def __new__() -> str:
        return str(Ptr[byte](), 0)
    def __new__[T](what: T) -> str: # lowest priority!
        return what.__str__()
    def __str__(what: str) -> str:
        return what
    def __len__(self) -> int:
        return self.len
    def __bool__(self) -> bool:
        return self.len != 0
    def __copy__(self) -> str:
        return self
    @internal
    def memcpy(dest: Ptr[byte], src: Ptr[byte], len: int) -> void: pass
    @internal
    def memmove(dest: Ptr[byte], src: Ptr[byte], len: int) -> void: pass
    @internal
    def memset(dest: Ptr[byte], b: byte, len: int) -> void: pass

extend bool:
    @internal
    def __new__() -> bool: pass
    def __new__[T](what: T) -> bool: # lowest priority!
        return what.__bool__()
    @internal
    def __str__(self) -> str: pass
    @internal
    def __copy__(self) -> bool: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __invert__(self) -> bool: pass
    @internal
    def __eq__(self, other: bool) -> bool: pass
    @internal
    def __ne__(self, other: bool) -> bool: pass
    @internal
    def __lt__(self, other: bool) -> bool: pass
    @internal
    def __gt__(self, other: bool) -> bool: pass
    @internal
    def __le__(self, other: bool) -> bool: pass
    @internal
    def __ge__(self, other: bool) -> bool: pass
    @internal
    def __and__(self, other: bool) -> bool: pass
    @internal
    def __or__(self, other: bool) -> bool: pass
    @internal
    def __xor__(self, other: bool) -> bool: pass

extend byte:
    @internal
    def __new__() -> byte: pass
    @internal
    def __new__(b: byte) -> byte: pass
    @internal
    def __new__(i: int) -> byte: pass
    @internal
    def __str__(self) -> str: pass
    @internal
    def __copy__(self) -> byte: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __eq__(self, other: byte) -> bool: pass
    @internal
    def __ne__(self, other: byte) -> bool: pass
    @internal
    def __lt__(self, other: byte) -> bool: pass
    @internal
    def __gt__(self, other: byte) -> bool: pass
    @internal
    def __le__(self, other: byte) -> bool: pass
    @internal
    def __ge__(self, other: byte) -> bool: pass
    @internal
    def comp(self) -> byte: pass

extend float:
    @internal
    def __new__() -> float: pass
    @internal
    def __new__(f: float) -> float: pass
    @internal
    def __new__(i: int) -> float: pass
    @internal
    def __str__(self) -> str: pass
    @internal
    def __copy__(self) -> float: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __pos__(self) -> float: pass
    @internal
    def __neg__(self) -> float: pass
    @internal
    def __abs__(self) -> float: pass
    @internal
    def __add__(self, other: float) -> float: pass
    @internal
    def __sub__(self, other: float) -> float: pass
    @internal
    def __mul__(self, other: float) -> float: pass
    @internal
    def __div__(self, other: float) -> float: pass
    @internal
    def __truediv__(self, other: float) -> float: pass
    @internal
    def __mod__(self, other: float) -> float: pass
    @internal
    def __pow__(self, other: float) -> float: pass
    @internal
    def __eq__(self, other: float) -> bool: pass
    @internal
    def __ne__(self, other: float) -> bool: pass
    @internal
    def __lt__(self, other: float) -> bool: pass
    @internal
    def __gt__(self, other: float) -> bool: pass
    @internal
    def __le__(self, other: float) -> bool: pass
    @internal
    def __ge__(self, other: float) -> bool: pass
    @internal
    def __add__(self, other: int) -> float: pass
    @internal
    def __sub__(self, other: int) -> float: pass
    @internal
    def __mul__(self, other: int) -> float: pass
    @internal
    def __div__(self, other: int) -> float: pass
    @internal
    def __truediv__(self, other: int) -> float: pass
    @internal
    def __mod__(self, other: int) -> float: pass
    @internal
    def __pow__(self, other: int) -> float: pass
    @internal
    def __eq__(self, other: int) -> bool: pass
    @internal
    def __ne__(self, other: int) -> bool: pass
    @internal
    def __lt__(self, other: int) -> bool: pass
    @internal
    def __gt__(self, other: int) -> bool: pass
    @internal
    def __le__(self, other: int) -> bool: pass
    @internal
    def __ge__(self, other: int) -> bool: pass

extend Optional[T]:  # type
    @internal
    def __new__() -> Optional[T]: pass
    @internal
    def __new__(what: T) -> Optional[T]: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __invert__(self) -> T: pass
    def __str__(self) -> str:
        return 'None' if not self else str(~self)
optional = Optional

extend Generator[T]:  # class
    @internal
    def __iter__(self) -> Generator[T]: pass
    @internal
    def __raw__(self) -> Ptr[byte]: pass
    @internal
    def __done__(self) -> bool: pass
    @internal
    def __promise__(self) -> Ptr[T]: pass
    @internal
    def __resume__(self) -> void: pass
    @internal
    def __str__(self) -> str: pass

    @internal
    def next(self) -> T: pass
    @internal
    def done(self) -> bool: pass
    @internal
    def send(self, what: T) -> T: pass
    @internal
    def destroy(self) -> void: pass
generator = Generator

@internal
type Array[T](len: int, ptr: Ptr[T]):
    @internal
    def __new__(len: int) -> Array[T]: pass
    @internal
    def __new__(data: Ptr[T], len: int) -> Array[T]: pass
    @internal
    def __copy__(self) -> Array[T]: pass
    @internal
    def __len__(self) -> int: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __getitem__(self, index: int) -> T: pass
    @internal
    def __slice__(self, l: int, r: int) -> Array[T]: pass
    @internal
    def __slice_left__(self, r: int) -> Array[T]: pass
    @internal
    def __slice_right__(self, l: int) -> Array[T]: pass
    @internal
    def __setitem__(self, index: int, what: T) -> void: pass
array = Array

extend Int[N]:
    @internal
    def __new__() -> Int[N]: pass
    @internal
    def __new__(what: Int[N]) -> Int[N]: pass
    @internal
    def __new__(what: int) -> Int[N]: pass
    @internal
    def __new__(what: UInt[N]) -> Int[N]: pass
    @internal
    def __copy__(self) -> Int[N]: pass
    @internal
    def __hash__(self) -> int: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __pos__(self) -> Int[N]: pass
    @internal
    def __neg__(self) -> Int[N]: pass
    @internal
    def __invert__(self) -> Int[N]: pass
    @internal
    def __add__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __sub__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __mul__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __div__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __truediv__(self, other: Int[N]) -> float: pass
    @internal
    def __mod__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __lshift__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __rshift__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __eq__(self, other: Int[N]) -> bool: pass
    @internal
    def __ne__(self, other: Int[N]) -> bool: pass
    @internal
    def __lt__(self, other: Int[N]) -> bool: pass
    @internal
    def __gt__(self, other: Int[N]) -> bool: pass
    @internal
    def __le__(self, other: Int[N]) -> bool: pass
    @internal
    def __ge__(self, other: Int[N]) -> bool: pass
    @internal
    def __and__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __or__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __xor__(self, other: Int[N]) -> Int[N]: pass
    @internal
    def __pickle__(self, dest: Ptr[byte]) -> void: pass
    @internal
    def __unpickle__(src: Ptr[byte]) -> Int[N]: pass
    @internal
    def __str__(self) -> str: pass
    @internal
    def popcnt(self) -> int: pass

    def len() -> int:
        return N

extend UInt[N]:
    @internal
    def __new__() -> UInt[N]: pass
    @internal
    def __new__(what: UInt[N]) -> UInt[N]: pass
    @internal
    def __new__(what: int) -> UInt[N]: pass
    @internal
    def __new__(what: Int[N]) -> UInt[N]: pass
    @internal
    def __int__(self) -> int: pass
    @internal
    def __copy__(self) -> UInt[N]: pass
    @internal
    def __hash__(self) -> int: pass
    @internal
    def __bool__(self) -> bool: pass
    @internal
    def __pos__(self) -> UInt[N]: pass
    @internal
    def __neg__(self) -> UInt[N]: pass
    @internal
    def __invert__(self) -> UInt[N]: pass
    @internal
    def __add__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __sub__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __mul__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __div__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __truediv__(self, other: UInt[N]) -> float: pass
    @internal
    def __mod__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __lshift__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __rshift__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __eq__(self, other: UInt[N]) -> bool: pass
    @internal
    def __ne__(self, other: UInt[N]) -> bool: pass
    @internal
    def __lt__(self, other: UInt[N]) -> bool: pass
    @internal
    def __gt__(self, other: UInt[N]) -> bool: pass
    @internal
    def __le__(self, other: UInt[N]) -> bool: pass
    @internal
    def __ge__(self, other: UInt[N]) -> bool: pass
    @internal
    def __and__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __or__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __xor__(self, other: UInt[N]) -> UInt[N]: pass
    @internal
    def __pickle__(self, dest: Ptr[byte]) -> void: pass
    @internal
    def __unpickle__(src: Ptr[byte]) -> UInt[N]: pass
    @internal
    def __str__(self) -> str: pass
    @internal
    def __revcomp__(self) -> UInt[N]: pass

    @internal
    def popcnt(self) -> int: pass

    def len() -> int:
        return N

extend str:
    def __add__(self, other: str) -> str:
        len1 = self.len
        len2 = other.len
        len3 = len1 + len2
        p = Ptr[byte](len3)
        str.memcpy(p, self.ptr, len1)
        str.memcpy(p + len1, other.ptr, len2)
        return str(p, len3)

@builtin
def _test_failed(file: str, line: int, msg: str):
    s = "\033[1;31mTEST FAILED:\033[0m " + file + " (line " + str(line) + ")"
    if msg:
        s += ": " + msg
    print s
